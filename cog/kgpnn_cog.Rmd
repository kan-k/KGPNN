---
title: "cognitive_modelling"
author: "Kan Keeratimahat"
date: "10/07/2024"
output: html_document
---

#9 July

I plan to include a range of cognitive performance from subjects rather than age, see how I used depind below and do something similar

##Looking at the new file `ukb_latest-Cog.tsv`
20016 FLuid Intelligence (normally dist, 0-13)
6348  Duration to complete numeric path (trail #1) => left skewed 92 -2557
6350 	Duration to complete alphanumeric path (trail #2) => left skewed 160-2988
6373  Number of puzzles correctly solved => right skewed 0 - 15

```{r}
cog.dat<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Cog.tsv', sep = '\t', header = TRUE) #46535 53
summary(cog.dat)
#many missing values
```
The idea is to grab the mean of xxx.1.0 and xxx.2.0 and xxx.3.0 to average it.
```{r}
#fluid intelligence
cog.dat$fi <- apply(cbind(cog.dat$X20016.0.0,cog.dat$X20016.1.0,cog.dat$X20016.2.0,cog.dat$X20016.3.0),1,FUN = mean,na.rm=TRUE) 
#numeric path
cog.dat$num <- apply(cbind(cog.dat$X6348.2.0,cog.dat$X6348.3.0),1,FUN = mean,na.rm=TRUE) 
#alphanumeric
cog.dat$alphnum <- apply(cbind(cog.dat$X6350.2.0,cog.dat$X6350.3.0),1,FUN = mean,na.rm=TRUE) 
#puzzles
cog.dat$puzzle <-  apply(cbind(cog.dat$X6373.2.0,cog.dat$X6373.3.0),1,FUN = mean,na.rm=TRUE) 
```

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/age_sex_strat_depind.feather'))

#something along bottom line
for(i in 1:length(age_tab$id)){
  ind <- cog.dat$eid_8107==sub(".", "",age_tab$id[i])
  age_tab$fi[i] <- cog.dat$fi[ind]
  age_tab$num[i] <- cog.dat$num[ind]
  age_tab$alphnum[i] <- cog.dat$alphnum[ind]
  age_tab$puzzle[i] <- cog.dat$puzzle[ind]
  
} 
```
```{r}
summary(age_tab$fi)
summary(age_tab$num)
summary(age_tab$alphnum)
summary(age_tab$puzzle)
```

There are so many missing values. I think I will have to create another dataset for this.

Original data
```{r}
part_list<-read.table('/well/nichols/users/qcv214/Placement_2/participant_list.txt', header = FALSE, sep = "", dec = ".") #4529 participants
part_list$exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list[,1],'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
#These two are equal
part_use<-part_list[part_list$exist_vbm==1,] #4262 participants left
```

Extended data
```{r}
part_list2 <- read.csv('/well/nichols/users/qcv214/bnn2/add_1_part_id_use_final.txt')$V1 #4258
part_list2.exist_vbm <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',part_list2,'/T1/T1_vbm/T1_GM_to_template_GM_mod.nii.gz'))
part_use2 <-part_list2[part_list2.exist_vbm] #length = 4257
```

```{r}
part.combined <- c(part_use$V1,part_use2)
```

```{r}
agetab<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Age.tsv', sep = '\t', header = TRUE)
age_tab<-as.data.frame(matrix(,nrow = length(part.combined),ncol = 3)) #id, age, number of masked voxels
colnames(age_tab)[1:3]<-c('id','age','sex')
age_tab$id<-part.combined
# for(i in 1:length(part.combined)){
#   age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
#   age_tab$sex[i]<-agetab$X31.0.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
# }
```

###Deprivation index
```{r}
confs.dat<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Confs.tsv', sep = '\t', header = TRUE) #46535 53
confs.dat$combDepInd <- apply(cbind(confs.dat$X26410.0.0,confs.dat$X26427.0.0,confs.dat$X26426.0.0),1,FUN = mean,na.rm=TRUE) 
```


For the above, I should combine it with cognitive
###Cognitive
```{r}
cog.dat<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Cog.tsv', sep = '\t', header = TRUE) #46535 53
summary(cog.dat)
#many missing values
```
The idea is to grab the mean of xxx.1.0 and xxx.2.0 and xxx.3.0 to average it.
```{r}
#fluid intelligence
cog.dat$fi <- apply(cbind(cog.dat$X20016.0.0,cog.dat$X20016.1.0,cog.dat$X20016.2.0,cog.dat$X20016.3.0),1,FUN = mean,na.rm=TRUE) 
#numeric path
cog.dat$num <- apply(cbind(cog.dat$X6348.2.0,cog.dat$X6348.3.0),1,FUN = mean,na.rm=TRUE) 
#alphanumeric
cog.dat$alphnum <- apply(cbind(cog.dat$X6350.2.0,cog.dat$X6350.3.0),1,FUN = mean,na.rm=TRUE) 
#puzzles
cog.dat$puzzle <-  apply(cbind(cog.dat$X6373.2.0,cog.dat$X6373.3.0),1,FUN = mean,na.rm=TRUE) 
```

```{r}

#something along bottom line
for(i in 1:length(age_tab$id)){
  age_tab$age[i]<-agetab$X21003.2.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
  age_tab$sex[i]<-agetab$X31.0.0[agetab$eid_8107==sub(".", "",age_tab$id[i])]
  
  ind.dep <- confs.dat$eid_8107==sub(".", "",age_tab$id[i])
  age_tab$DepInd[i] <- confs.dat$combDepInd[ind.dep]
  
  ind <- cog.dat$eid_8107==sub(".", "",age_tab$id[i])
  age_tab$fi[i] <- cog.dat$fi[ind]
  age_tab$num[i] <- cog.dat$num[ind]
  age_tab$alphnum[i] <- cog.dat$alphnum[ind]
  age_tab$puzzle[i] <- cog.dat$puzzle[ind]
  
} 
# summary(age_tab$fi)
# summary(age_tab$num)
# summary(age_tab$alphnum)
# summary(age_tab$puzzle)
# dim is 8519 x 8
```

remove rows wityh any NaN
```{r}
age_tab2 <- na.omit(age_tab)
dim(age_tab2)
```

View the data distribution

```{r}
age_tab2 <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat.feather'))


for(i in 2:ncol(age_tab2)){
  
  if(i %in% c(5,6,8)){
    titl <- paste0("histogram of : log-",colnames(age_tab2)[i])
    hist(log(age_tab2[,i]), main = titl, xlab = paste0("log-",colnames(age_tab2)[i]))
  }
    # } else{
    titl <- paste0("histogram of : ",colnames(age_tab2)[i])
    hist((age_tab2[,i]), main = titl, xlab = colnames(age_tab2)[i])
  # }
  
}
```
I think there is nothing to stratify (apart from sex, which can perhaps be stratify during selection) after doing log transformation on tasks
Stratify by sex
```{r}
library(dplyr)
# Check the counts of each sex category
sex_counts <- table(age_tab2$sex)
# Determine the minimum count
min_count <- min(sex_counts)
# Stratify the data
balanced_age_tab <- age_tab2 %>%
  group_by(sex) %>%
  sample_n(size = min_count)
#left with 5204 subjects
```

Sort age by sex
```{r}
# Sort the entire dataframe by age and group by sex
balanced_age_tab <- balanced_age_tab %>%
  split(.$sex) %>%
  lapply(function(x) x[order(x$age),]) %>%
  bind_rows()
```


Save the data
##Data
```{r}
# write_feather(balanced_age_tab, '/well/nichols/users/qcv214/KGPNN/cog/agesex_strat.feather')
```

```{r}
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat.feather'))
```

Note that 5204/2.6 gives 2001
```{r}
train.ind <- round(seq(1,5204,2.6)) #gives 2002
train.ind <- train.ind[-2001:-2002]

test.ind <- round(seq(2,5204,2.6)) #gives 2001
test.ind <- test.ind[-2001]

#test overlap
sum(train.ind %in% test.ind) # = 0, so no overlap


```

Look at the dist
Train
```{r}
for(i in 2:ncol(age_tab2)){
  
  if(i %in% c(5,6,8)){
    titl <- paste0("histogram of : log-",colnames(age_tab2)[i])
    hist(log(age_tab2[train.ind,i]), main = titl)
  } else{
    titl <- paste0("histogram of : ",colnames(age_tab2)[i])
    hist((age_tab2[train.ind,i]), main = titl)
  }
  
}
```

Test
```{r}
for(i in 2:ncol(age_tab2)){
  
  if(i %in% c(5,6,8)){
    titl <- paste0("histogram of : log-",colnames(age_tab2)[i])
    hist(log(age_tab2[test.ind,i]), main = titl)
  } else{
    titl <- paste0("histogram of : ",colnames(age_tab2)[i])
    hist((age_tab2[test.ind,i]), main = titl)
  }
  
}
```

```{r}
write.csv(train.ind, file = '/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv', row.names = FALSE)
write.csv(test.ind, file = '/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv', row.names = FALSE)
```




###Some note on stratifying
####Stratify the data by using downsampling on sex
```{r}
# Check the counts of each sex category
sex_counts <- table(age_tab$sex)
# Determine the minimum count
min_count <- min(sex_counts)
# Stratify the data
balanced_age_tab <- age_tab %>%
  group_by(sex) %>%
  sample_n(size = min_count)
```
This `balanced_age_tab` is stratified correctly, and ordered by sex. amount is 1971 in each.

Sort age by sex
```{r}
# Sort the entire dataframe by age and group by sex
balanced_age_tab <- balanced_age_tab %>%
  split(.$sex) %>%
  lapply(function(x) x[order(x$age),]) %>%
  bind_rows()
```

```{r}
#write_feather(balanced_age_tab, '/well/nichols/users/qcv214/KGPNN/age_sex_strat.feather')
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/age_sex_strat.feather'))
```




Running 
[canceled] july10_num_sm_gpnn_init 678437 => modelling log(num) with 10 subclasses.  ===> it takes too long per epoch, i will change it to 250 search
//re_cog_july10_ridge (and lasso) 680547 => ridge and lasso with non-imaging... accidentally saved in the old folder
//july10_num_sm_gpols_init 681168 


##Load up ridge and lasso results
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/pile/re_cog_july10_lasso_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/pile/re_cog_july10_ridge_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

```
Lasso is better on held-out than ridge. Interesting

#11 July

##Plot param search of gpolsoptions(bitmapType='cairo')
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july10_num_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,.5) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
There doesnt'seem to be any learning overtime. Let's try bbs.

running
[Wrong] july10_num_sm_gpols_init_bbs 809259  ===> it's WRONG I was evaluating age but not lognum. I'll delete it
//july10_num_sm_gpols_init_bbs 1034923
//july10_num_sm_gpnn_init 809303 => modelling log(num) with 10 subclasses.  250 search



#12 July
## gpols bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july10_num_sm_gpols_init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(log(age_tab$num)), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.4) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(log(age_tab$num)), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.4) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
It shouldn't be shotting up like this, this is unacceptable results.  ****



##Gpnn
##Plot param search of gpolsoptions(bitmapType='cairo')
```{r}
library(ggplot2)
library(tidyr)

num.it <- 250*4
runs <- c(3,5:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july10_num_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.5) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
This still doesn't beat linear model. let's try bbs and see

Running
[1,5,6,7,8,10] //july10_num_sm_gpnn_init_bbs. 1038515
```{r}
library(ggplot2)
library(tidyr)

num.it <- 250*4
runs <- c(1,5,6,7,8,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july10_num_sm_gpnn_init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(log(age_tab$num)), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.4) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(log(age_tab$num)), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.2,.4) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
why is GPNN worse than GPOLS

Let's look at sd of our problem

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat.feather'))
#age_tab <- age_tab[order(age_tab$id),].     #DOES THIS MESS UP ORDER
lognum <- log(age_tab$num)
print(sd(lognum))
```

What if we try modelling the raw values instead of log num? perhaps non-gaussian assumption can make gpnn standout?

Running
july14_rawnum_sm_gpnn_init 1152691
july14_rawnum_sm_gpols_init 1152693
re_rcog_july14_ridge (and lasso) 1166295

#15 July

Doing `raw num` instead of `log num`

##Load up ridge and lasso results
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rcog_july14_lasso_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rcog_july14_ridge_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

```
Lasso held out is better than held in??

##gpols
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july14_rawnum_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(60,100) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(40,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

##gpnn
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(2,6,9)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july14_rawnum_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(70,100) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

All these seem to be overfitting, I will reduce number of latent classes to 3

[2,4,5,7,8]july15_rawnum_sm_gpnn_init 1174402
//july15_rawnum_sm_gpols_init 1173756 

We can try to model alpha-num 
july15_rawalp_sm_gpols_init 1177261
july15_rawalp_sm_gpnn_init 1177288

#16 July
## july15_rawnum_sm_gpols_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(1:5,7:8)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july15_rawnum_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(70,100) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
reducing number of classes doesn't help gpnn.

##july15_rawnum_sm_gpols_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:9
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july15_rawnum_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(70,100) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$num), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
reducing number of classes doesn't help gpnn.

##Raw Alpha - Numeric
###july15_rawalp_sm_gpols_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july15_rawalp_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$alphnum), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(70,400) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$alphnum), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,400) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
###GPNN
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(2,4)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july15_rawalp_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$alphnum), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(70,400) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$alphnum), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,400) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

Does

#Need to grab another variable
See `https://www.ukbiobank.ac.uk/enable-your-research/approved-research/identifying-genetic-factors-for-brain-ageing`
Pairs matching task => bimodal.
I copied `/well/nichols/scripts/Extract_Cog2.sh` and run it using `bash ` and save everything to the folder `/well/nichols/users/qcv214/KGPNN/cog/Cog_dat`

##Loading
```{r}
cog.dat<-read.table(file = '/well/nichols/users/qcv214/KGPNN/cog/Cog_dat/ukb_latest-Cog2.tsv', sep = '\t', header = TRUE) #46535 53
# summary(cog.dat)
#many missing values
colnames(cog.dat)
```

Comparing
```{r}
cog.dat2<-read.table(file = '/well/nichols/projects/UKB/SMS/ukb_latest-Cog.tsv', sep = '\t', header = TRUE) #46535 53
# summary(cog.dat)
#many missing values
```

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat.feather'))
```


Pair Matching task
***Note that I am using the median across all, probably in real use, we wanna use latest info,
```{r}
# cog.dat$pm <- apply(cbind(cog.dat$X400.0.1, cog.dat$X400.0.2, cog.dat$X400.1.1, cog.dat$X400.1.2, cog.dat$X400.2.1, cog.dat$X400.2.2, cog.dat$X400.2.3, cog.dat$X400.3.1, cog.dat$X400.3.2, cog.dat$X400.3.3 ),1,FUN = mean,na.rm=TRUE) 
cog.dat$pm <- apply(cbind(cog.dat$X400.2.1, cog.dat$X400.2.2, cog.dat$X400.2.3 ),1,FUN = mean,na.rm=TRUE) 
```

There is 
```{r}

#something along bottom line
for(i in 1:length(age_tab$id)){
  ind <- cog.dat$eid_8107==sub(".", "",age_tab$id[i])
  age_tab$pm[i] <- cog.dat$pm[ind]
  
} 
summary(age_tab$pm)
# dim is 8519 x 8
```
there is 94 (prev 1 on full median) missing value, I will imput it by median
```{r}
age_tab$pm[which(is.na(age_tab$pm))] <- median(age_tab$pm, na.rm = TRUE)
```

```{r}
hist(age_tab$pm)
plot(density((age_tab$pm[age_tab$pm < 700])))
```
Somehow it's unimodal... we want bimodal
```{r}
# write_feather(age_tab, '/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather')
```

july16_rawpm_sm_gpols_init 1306485
july16_rawpm_sm_gpnn_init 1306504
re_rpm_july16_ridge (and lasso) 1386759
#17 July
##Pair matching
###Load up ridge and lasso results
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_july16_lasso_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){xw
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_july16_ridge_noscale_",i,".csv"))))
}
# (hs.train <- quantile(hs.int[,1],c(0.25,0.5,0.75)))
# (hs.test <-quantile(hs.int[,3],c(0.25,0.5,0.75)))

(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

```

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```

###july16_rawpm_sm_gpols_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july16_rawpm_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(100,120) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(50,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
it's worse than the noise on held-out, 

###GPNN
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(1:7)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july16_rawpm_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(100,120) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(50,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

I just realised that the training and test sd are entirely different.

I want to tr

Ridge and Lasso still beat our algorithm

##to do
I wanna run the imaging-only version for all these

//re_rpm_imaging_july16_ridge (and lasso)  1441828

//[1:4,6:9] july16_rawpm_gpnn_init 1608446

###Load up ridge and lasso results with imaging only
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_july16_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_july16_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))
print("===== below with with imaging only =====")
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_imaging_july16_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_rpm_imaging_july16_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

```
Imaging only is better for ridge but worse for lasso. Ridge now beats lasso.

###GPNN Imaging only
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(1:4,6:9)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july16_rawpm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(100,120) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(50,100) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
Still worse than ridge and lasso, converge at response sd
Basically SAME as k-GPNN

#18 july

##Inverse nornmal transformation
```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
age_tab$pm_tf <- qnorm((rank(age_tab$pm,na.last="keep")-0.5)/sum(!is.na(age_tab$pm)))
# write_feather(age_tab, '/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather')
```


###UPDATE 8 AUG 24
I am applying inverse transform on held-in, keep the pre-learn transformation and apply it onto held-out.

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```
```{r}
# Load necessary packages
if (!require(scales)) install.packages("scales")
if (!require(caret)) install.packages("caret")
library(scales)
library(caret)
library(ggplot2)

# Assuming age_tab and train.test.ind are already defined with the response variable called 'pm'

# Function to perform Gaussian Inverse Transformation on training data
gaussian_inverse_transform_train <- function(response_variable) {
  # Rank transformation
  ranks <- rank(response_variable)
  
  # Normal quantile transformation
  normal_quantiles <- qnorm((ranks - 0.5) / length(ranks))
  
  return(list(
    transformed = normal_quantiles,
    ecdf_fn = ecdf(response_variable)  # Empirical CDF function for the training data
  ))
}

# Apply pre-learned transformation to new data
apply_prelearned_transformation <- function(test_response_variable, ecdf_fn) {
  # Apply the ECDF to the test data
  ecdf_values <- ecdf_fn(test_response_variable)
  
  # Replace exact 0 and 1 values
  ecdf_values[ecdf_values == 0] <- .Machine$double.eps
  ecdf_values[ecdf_values == 1] <- 1 - .Machine$double.eps
  
  # Normal quantile transformation using the ECDF values
  normal_quantiles <- qnorm(ecdf_values)
  
  return(normal_quantiles)
}

# Learn the transformation on the training set
train_indices <- train.test.ind$train
test_indices <- train.test.ind$test

train_lognum <- age_tab$pm[train_indices]

# Apply the Gaussian Inverse Transformation on the training set
train_transformation <- gaussian_inverse_transform_train(train_lognum)

# Add the transformed training values back to the dataframe
age_tab$pm_tf <- NA
age_tab$pm_tf[train_indices] <- train_transformation$transformed

# Apply the learned transformation on the test set
test_lognum <- age_tab$pm[test_indices]
test_transformed <- apply_prelearned_transformation(test_lognum, train_transformation$ecdf_fn)

# Add the transformed test values back to the dataframe
age_tab$pm_tf[test_indices] <- test_transformed

# write_feather(age_tab, '/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather')
```


```{r}
hist(age_tab$pm_tf)
plot(density(age_tab$pm_tf))
```
This looks almost perfectly normal


Look at densities of train and test
```{r}
plot(density(age_tab$pm[train.test.ind$train]), main = "Density Plot of Pair Matching",
     xlab = "pm", ylab = "Density", col = "blue", lwd = 2)
lines(density(age_tab$pm[train.test.ind$test]), col = "red", lwd = 2)
legend('topright',legend = c('Training','Test'),lty=c(1),col=c('blue','red'))

```
```{r}
plot(density(age_tab$pm_tf[train.test.ind$train]), main = "Density Plot of Normal-inversed transformed of Pair Matching",
     xlab = "transformed pair matching", ylab = "Density", col = "blue", lwd = 2)
lines(density(age_tab$pm_tf[train.test.ind$test]), col = "red", lwd = 2)
legend('topright',legend = c('Training','Test'),lty=c(1),col=c('blue','red'))
```

##let's model this new pm_tf

//re_pm_july16_ridge (and lasso) 1492677
//[2:5,7,8,10]july18_pm_sm_gpnn_init 1492725
//july18_pm_sm_gpols_init 1492746
//[1:3,5,6,9,10]july18_pm_gpnn_init 1609389

#19 July 
```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```
###Ridge
```{r}
#lasso
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_pm_july16_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:1
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_pm_july16_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july22_pm_gpr_noscale_",i,".csv"))))
}
(gpr.train <- quantile(hs.int[,5],c(0.5)))
(gpr.test <-quantile(hs.int[,6],c(0.5)))
```

###july16_rawpm_sm_gpols_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- 1:10
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july18_pm_sm_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.9,1.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.7,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

###july18_rawpm_sm_gpnn_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(2:5,7,8,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july18_pm_sm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +

    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.97,1.15) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

###july18_rawpm_gpnn_init
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(1:3,5,6,9,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july18_pm_gpnn_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.97,1.15) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
Okay this isn't bad actually.
I think k-GPNN is similar to gpnn.

Let's run BBS. (may try bbs ridge?)
//[4,5,7] july18_pm_sm_gpnn_init_bbs. 1787834

#22 July
###july18_rawpm_sm_gpnn_init bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(4,5,7)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july18_pm_sm_gpnn_init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.9,1.5) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

It's weird. It only learns the noise, even tho minimum should really be same as lasso and ridge.
I think Train vs Test plots show that as soon as it overfits, the algorithm just captures noise.

I will reduce number of regions

##To do
I think I should tune the number hidden neurons down for this version.

GPR
//re_july22_pm_gpr  1895497 


#24 july
// [c(1,3:8,10)]july24_pm_sm_gpnn_12init  2214055 => reduce from 53 regions to 12 ===> 10 hours (reduced from 30)

```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1,3:8,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july24_pm_sm_gpnn_12init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

Run bbs 
//july24_pm_sm_gpnn_12init_bbs  2287225


##bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(2:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july24_pm_sm_gpnn_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```


#26 july

##To do

1. Run gpols but with 12 number of regions (and 20 degs)
//july26_pm_sm_gpols_12init  2496385
2.Try bimodal


##gpols param search

```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_sm_gpols_12init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```



##biomodal data

```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```

#check for existing Default Mode Network
```{r}
age_tab$dmn <- file.exists(paste0('/well/win-biobank/projects/imaging/data/data3/subjectsAll/',age_tab$id,'/fMRI/rfMRI_25.dr/dr_stage2.nii.gz')) #4545 subjects, 87%
age_tab_dmn <- age_tab[age_tab$dmn == TRUE, ]
# write_feather(age_tab_dmn, '/well/nichols/users/qcv214/KGPNN/cog/age_dmn_sex_strat.feather')
```

```{r}
train.ind <- round(seq(1,4545,2.27)) #gives 2002
train.ind <- train.ind[-2001:-2002]

# test.ind <- round(seq(2,4545,2.26)) #gives 2002
# test.ind <- test.ind[-2001:-2002]
test.ind <- train.ind+1 
#test overlap
sum(train.ind %in% test.ind) # = 897, so many overlaps
```
###12 August, correct inverse transform

```{r}
# Load necessary packages
if (!require(scales)) install.packages("scales")
if (!require(caret)) install.packages("caret")
library(scales)
library(caret)
library(ggplot2)

# Assuming age_tab and train.test.ind are already defined with the response variable called 'pm'

# Function to perform Gaussian Inverse Transformation on training data
gaussian_inverse_transform_train <- function(response_variable) {
  # Rank transformation
  ranks <- rank(response_variable)
  
  # Normal quantile transformation
  normal_quantiles <- qnorm((ranks - 0.5) / length(ranks))
  
  return(list(
    transformed = normal_quantiles,
    ecdf_fn = ecdf(response_variable)  # Empirical CDF function for the training data
  ))
}

# Apply pre-learned transformation to new data
apply_prelearned_transformation <- function(test_response_variable, ecdf_fn) {
  # Apply the ECDF to the test data
  ecdf_values <- ecdf_fn(test_response_variable)
  
  # Replace exact 0 and 1 values
  ecdf_values[ecdf_values == 0] <- .Machine$double.eps
  ecdf_values[ecdf_values == 1] <- 1 - .Machine$double.eps
  
  # Normal quantile transformation using the ECDF values
  normal_quantiles <- qnorm(ecdf_values)
  
  return(normal_quantiles)
}

# Learn the transformation on the training set
train_indices <- train.ind
test_indices <- test.ind

train_lognum <- age_tab_dmn$pm[train_indices]

# Apply the Gaussian Inverse Transformation on the training set
train_transformation <- gaussian_inverse_transform_train(train_lognum)

# Add the transformed training values back to the dataframe
age_tab_dmn$pm_tf <- NA
age_tab_dmn$pm_tf[train_indices] <- train_transformation$transformed

# Apply the learned transformation on the test set
test_lognum <- age_tab_dmn$pm[test_indices]
test_transformed <- apply_prelearned_transformation(test_lognum, train_transformation$ecdf_fn)

# Add the transformed test values back to the dataframe
age_tab_dmn$pm_tf[test_indices] <- test_transformed
write_feather(age_tab_dmn, '/well/nichols/users/qcv214/KGPNN/cog/age_dmn_sex_strat.feather')
```

```{r}
plot(density(age_tab_dmn$pm_tf[train.ind]), main = "Density Plot of Normal-inversed transformed of Pair Matching",
     xlab = "transformed pair matching", ylab = "Density", col = "blue", lwd = 2)
lines(density(age_tab_dmn$pm_tf[test.ind]), col = "red", lwd = 2)
legend('topright',legend = c('Training','Test'),lty=c(1),col=c('blue','red'))
```


```{r}
# write.csv(train.ind, file = '/well/nichols/users/qcv214/KGPNN/cog/cog_dmn_train_index.csv', row.names = FALSE)
# write.csv(test.ind, file = '/well/nichols/users/qcv214/KGPNN/cog/cog_dmn_test_index.csv', row.names = FALSE)
```

//[2,4,8,9] july26_pm_bi_gpnn_init 2586241  (16 slots)
//july26_pm_sm_gpols_12init_bbs  2508689


##GPOLS bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_sm_gpols_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.6,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

In some iteration, it DOES beat lasso and ridge. Interesting.
Look at run 3,5,6,10

Maybe try GPNN GP GP???

//[1,4,6:10] july26_pm_sm_gpgp_12init 2600564 ==> takes 2 hours (cpmpared to 1 hours of gpols)

##gpgp param search
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1,4,6:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_sm_gpgp_12init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.6,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

// [1,2,3,5,6,10]july26_pm_sm_gpgp_12init_bbs. 2607330


##gpgp bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1,2,3,5,6,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_sm_gpgp_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.6,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
gpgp isn't good.




//[] july26_pm_bi_gpnn_init_bbs 2684755


#28 july

##gpgp bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(2,8,9,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_bi_gpnn_init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

This is interesting, it can achieve rmse of 0 while maintaining decent test rmse.

#4 aug

##To do

1. Run GPNN without latent class, but with 12 number of regions
aug4_pm_gpnn_12init 3448243

2. observe the stability and interpretability of latent classes in bbs

##Observe class assignment 

###
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)  # Ensure this package is installed for reading feather files

# Load the age and sex stratified data
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- 1:10

for (r in success.run) {
  # Load and process data
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_july26_pm_sm_gpols_12init_bbs_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd','pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$age)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd','pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError,pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```

3,5,6,10 from good held-out RMSE


#6 Aug

##GPNN without latent class
###param search
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:8,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug4_pm_gpnn_12init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

//aug4_pm_gpnn_12init_bbs  3705710

#7 Aug
##GPNN Plot bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(2,3,6,9)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug4_pm_gpnn_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.3) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
GPNN without latent classes overfits too easily. This is good findings, meaning the k-GPNN is better

Is it OLS-GP that I need to compare it to tho??

//aug7_pm_gpols_12init. 3869534

##GPOLS without latent class
###param search
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug7_pm_gpols_12init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```


//aug7_pm_gpols_12init_bbs  3876485
##GPOLS bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug7_pm_gpols_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
This is saying that WITHOUT latent class, gpols version is worse than k-gpols!!!

Note that the current test s.d. line isn't correct, I am to re-run the analysis on the new pm transformation.


#8 Aug

IMPORTANT:
I have overwrote the save of `agesex_strat2.feather`. I am applying inverse transform on held-in, keep the pre-learn transformation and apply it onto held-out.


I will re-run everything.

[1:10]//aug9_pm_gpols_12init  4090379
//re_aug9_pm_gpr_noscale_  4090389
//re_pm_aug9_ridge_noscale_ 4090399
[1:5,7,8,10]// aug9_pm_sm_gpgp_12init  4090427
[2,3,8:10]//aug9_pm_sm_gpnn_12init  4090462
[1:10]//aug9_pm_sm_gpols_12init  4090443
[1:4,8,9]//aug9_pm_bi_gpnn_init   4090467
aug9_pm_bi_gpols_init 4379501 ==> new

###bbs

[1:10] aug9_pm_gpols_12init_bbs 4363146
[1:8,10] aug9_pm_sm_gpgp_12init_bbs  4363162
[1,2,4,6,10] aug9_pm_sm_gpnn_12init_bbs  4363177
[1:10]aug9_pm_sm_gpols_12init_bbs  4363170
[2,7,9] aug9_pm_bi_gpnn_init_bbs   4363181

#9 aug 
```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x
```
###Ridge
```{r}
#lasso
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_pm_aug9_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_pm_aug9_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_gpr_noscale_",i,".csv"))))
}
(gpr.train <- quantile(hs.int[,5],c(0.5)))
(gpr.test <-quantile(hs.int[,6],c(0.5)))
```

##Now do all the plotting
[1:10] aug9_pm_gpols_12init_bbs 4363146
[1:8,10] aug9_pm_sm_gpgp_12init_bbs  4363162
[1,2,4,6,10] aug9_pm_sm_gpnn_12init_bbs  4363177
[1:10]aug9_pm_sm_gpols_12init_bbs  4363170
[2,7,9] aug9_pm_bi_gpnn_init_bbs   4363181
###vanilla gpols Plot bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_gpols_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.88,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
###gpols bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(2:3,5:6,9)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.88,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
###gpgp bbs

```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:8,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpgp_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
###gpnn bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1,2,4,6,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpnn_12init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

####Observe class assignment 


```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)  # Ensure this package is installed for reading feather files
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(2,3,5,9)

for (r in success.run) {
  # Load and process data
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_bbs_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd','pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd','pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError,pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)  # Ensure this package is installed for reading feather files

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(2, 3, 5, 9)

for (r in success.run) {
  # Load and process data
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_bbs_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```



Actually I need to re-save stuff onto dmn response variable too, so it's wrong right now.

[2,6,7,9]//aug9_pm_bi_gpols_init. 4404012 ==> reduce max mag of lr
[3,4,10] aug9_pm_bi_gpnn_init 4403909


Note that I need to run GPR, LASSO, Ridge for bimodal

//re_aug13_bimodal_ridge. 4654683
//re_aug13_bimodal_pm_gpr 4652713
```{r}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/age_dmn_sex_strat.feather'))
train.test.ind <- list()
train.test.ind$test <- read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_dmn_test_index.csv')$x
train.test.ind$train <-  read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_dmn_train_index.csv')$x
```

###Ridge
```{r}
#lasso
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug13_bimodal_lasso_noscale_",i,".csv"))))
}
(l.train <- quantile(hs.int[,5],c(0.5)))
(l.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug13_bimodal_ridge_noscale_",i,".csv"))))
}
(r.train <- quantile(hs.int[,5],c(0.5)))
(r.test <-quantile(hs.int[,6],c(0.5)))

#ridge
runs.hs <- 1:10
hs.int<-matrix(,nrow=length(runs.hs),ncol=13)
for(i in runs.hs){
  hs.int[which(i==runs.hs),] <- t(as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug13_bimodal_pm_gpr_noscale_",i,".csv"))))
}
(gpr.train <- quantile(hs.int[,5],c(0.5)))
(gpr.test <-quantile(hs.int[,6],c(0.5)))
```

##bi gpols
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(2,6,7,9)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_bi_gpols_init_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.97,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```


##bi gpols
```{r}
library(ggplot2)
library(tidyr)

num.it <-250*4
runs <- c(3,4,10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_bi_gpnn_init_bbs_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.97,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```
#18 Aug

Testing sgld. 
I am only doing sgld on gpols and present it first to see if we need it. GPNN and GPGP vcan be done later

//aug9_pm_sm_gpols_12init_sgld 6246995
//aug9_pm_gpols_12init_sgld 6347708

###gpols bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_sgld_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.88,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```

We can just pick a sensible run to assess, e.g. run 3

###gpols bbs
```{r}
library(ggplot2)
library(tidyr)

num.it <-500*4
runs <- c(1:10)
res.mat <- array(,dim=c(2,length(runs),num.it))
for(i in runs){
  res.mat[,which(i==runs),] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_gpols_12init_sgld_loss__jobid_",i,".csv")))[,1:num.it]
 }

# Assuming resdat is your dataframe
# Add a row identifier
resdat <- as.data.frame(sqrt(res.mat[2,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.99,1.1) +
  theme_minimal() +
  labs(title = "Test RMSE", x = "iterations", y = "Value", color = "Run number")

resdat <- as.data.frame(sqrt(res.mat[1,,]))
colnames(resdat) <- 1:ncol(resdat)
resdat$row_id <- seq_len(nrow(resdat))
# Reshape the data to long format
resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
# Create the line plot
ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
  geom_line() +
  geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
  geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
  scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
  ylim(0.88,1.1) +
  theme_minimal() +
  labs(title = "Train RMSE",x = "iterations", y = "Value", color = "Run number")
```


#19 August

SGLD
###getting sgld results
```{r}
for(i in c(9)){
  print(i)
  res <- read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/summary_re_aug9_pm_sm_gpols_sgld_",i,".csv" ))$x
  names(res) <-  c("inRMSE","outRMSE","inR2","outR2","in-Coverage","out-Coverage","in-PPIwidth","out-PPIwidth","inMAE","outMAE", "G1", "G2")
  print(res)
  print("---")
}
```
There are clear distinctions between good and bad runs
Let's look at 7,9,10

Held-in
```{r}
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}
age_tab <-  as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(2,3,5,9)

for(r in success.run){
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_sgld_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in,n.test/4*1000)
  colnames(dat.in) <- c('id_ind','pred','class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <-  dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in,n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

# Merge with age and sex information
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd','pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd','pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError,pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c( 9)

for (r in success.run) {
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug9_pm_sm_gpols_12init_sgld_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```
Calculating the 2.5 and 97.5 IQR
```{r}
for(C in c(1,2,3)){
  quants95 <- quantile(age.in[age.in$class==C,'pm_tf'], probs = c(0.025,0.975))
  print(quants95[2]-quants95[1])
}
```

###getting sgld result of No-class GP-OLS
```{r}
for(i in c(9)){
  print(i)
  res <- read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/summary_re_aug9_pm_gpols_sgld_",i,".csv" ))$x
  names(res) <-  c("inRMSE","outRMSE","inR2","outR2","in-Coverage","out-Coverage","in-PPIwidth","out-PPIwidth","inMAE","outMAE")
  print(res)
  print("---")
}
```


#22 Aug

//aug22_pm_sm_gpols_12init_K. 8191439 ==> K = 2,4,5
//aug22_pm_sm_gpols_12init_K_bbs  8315986  ==> K = 2,4,5

//aug22_pm_sm_gpols_12init_K. 8315998 ==> K = 8,12,15
//aug22_pm_sm_gpols_12init_K_bbs 8317449==> K = 8,12,15

###gpols bbs
#### varying K
```{r}
library(ggplot2)
library(tidyr)

num.class <- c(2, 4, 5)
num.it <- 500 * 4
runs <- c(1:10)

for(Class in num.class){

  res.mat <- array(, dim = c(2, length(runs), num.it))
  for(i in runs){
    res.mat[, which(i == runs), ] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_bbs_K", Class, "_loss__jobid_", i, ".csv")))[, 1:num.it]
  }

  # Test RMSE plot
  resdat <- as.data.frame(sqrt(res.mat[2,,]))
  colnames(resdat) <- 1:ncol(resdat)
  resdat$row_id <- seq_len(nrow(resdat))
  resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
  
  test_plot <- ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
    geom_line() +
    geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
    scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
    ylim(0.99, 1.1) +
    theme_minimal() +
    labs(title = paste("Test RMSE for Class", Class), x = "Iterations", y = "Value", color = "Run number")
  
  print(test_plot)  # Print the Test RMSE plot
  
  # Train RMSE plot
  resdat <- as.data.frame(sqrt(res.mat[1,,]))
  colnames(resdat) <- 1:ncol(resdat)
  resdat$row_id <- seq_len(nrow(resdat))
  resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
  
  train_plot <- ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
    geom_line() +
    geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
    scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
    ylim(0.88, 1.1) +
    theme_minimal() +
    labs(title = paste("Train RMSE for Class", Class), x = "Iterations", y = "Value", color = "Run number")
  
  print(train_plot)  # Print the Train RMSE plot
}
```

We can already see here that as K increases, training RMSE goes down whereas test RMSE go up.

Let's look at the class of K = 2
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)  # Ensure this package is installed for reading feather files

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(1:10)

for (r in success.run) {
  # Load and process data
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_bbs_K2_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```

The split are pretty consistent. Not 100% overlap between runs but I think very close enough. All class dists are very similar,

I think the rule is to increase K until class dist get unstable.

#26 August
###gpols bbs
#### varying K = 8,12,15
```{r}
library(ggplot2)
library(tidyr)

num.class <- c(2, 4, 5,8,12,15)
num.it <- 500 * 4
runs <- c(1:10)

for(Class in num.class){

  res.mat <- array(, dim = c(2, length(runs), num.it))
  for(i in runs){
    res.mat[, which(i == runs), ] <- as.matrix(read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_bbs_K", Class, "_loss__jobid_", i, ".csv")))[, 1:num.it]
  }

  # Test RMSE plot
  resdat <- as.data.frame(sqrt(res.mat[2,,]))
  colnames(resdat) <- 1:ncol(resdat)
  resdat$row_id <- seq_len(nrow(resdat))
  resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
  
  test_plot <- ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
    geom_line() +
    geom_hline(aes(yintercept = r.test, color = "Ridge"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = l.test, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = gpr.test, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$test]), color = "sd response"), linetype = "dashed", size = 1) +
    scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
    ylim(0.99, 1.1) +
    theme_minimal() +
    labs(title = paste("Test RMSE for Class", Class), x = "Iterations", y = "Value", color = "Run number")
  
  print(test_plot)  # Print the Test RMSE plot
  
  # Train RMSE plot
  resdat <- as.data.frame(sqrt(res.mat[1,,]))
  colnames(resdat) <- 1:ncol(resdat)
  resdat$row_id <- seq_len(nrow(resdat))
  resdat_long <- pivot_longer(resdat, cols = -row_id, names_to = "column", values_to = "value")
  
  train_plot <- ggplot(resdat_long, aes(x = as.numeric(column), y = value, group = row_id, color = as.factor(row_id))) +
    geom_line() +
    geom_hline(aes(yintercept = r.train, color = "Ridge"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = l.train, color = "Lasso"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = gpr.train, color = "GPR"), linetype = "dashed", size = 1) +
    geom_hline(aes(yintercept = sd(age_tab$pm_tf[train.test.ind$train]), color = "sd response"), linetype = "dashed", size = 1) +
    scale_x_continuous(breaks = seq(0, max(as.numeric(resdat_long$column)), by = 500)) +
    ylim(0.88, 1.1) +
    theme_minimal() +
    labs(title = paste("Train RMSE for Class", Class), x = "Iterations", y = "Value", color = "Run number")
  
  print(train_plot)  # Print the Train RMSE plot
}
```
For 8,12,15, the results are basically indisnguishable, they are not bad tho but worse than K = 2
Let's look at the class of K = 8
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)  # Ensure this package is installed for reading feather files

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(1:10)

for (r in success.run) {
  # Load and process data
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_bbs_K15_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  
  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```
So looking at K = 8 and K = 15, the max number of classes are 6. It no longer exhaust all number of classes.


Runnning
//aug22_pm_sm_gpols_12init_sgld 9686098

GLD
###getting sgld results
```{r}
for(i in c(1:10)){
  print(i)
  res <- read.csv(paste0("/well/nichols/users/qcv214/KGPNN/cog/pile/summary_re_aug22_pm_gpols_sgld_K2_",i,".csv" ))$x
  names(res) <-  c("inRMSE","outRMSE","inR2","outR2","in-Coverage","out-Coverage","in-PPIwidth","out-PPIwidth","inMAE","outMAE", "G1", "G2")
  print(res)
  print("---")
}
```

Run 4 has terrible held-out
All runs seem pretty consistent

Held-in

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(1:10)

for (r in success.run) {
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```
```{r}
for(C in c(1,2)){
  quants95 <- quantile(age.in[age.in$class==C,'pm_tf'], probs = c(0.025,0.975))
  print(quants95[2]-quants95[1])
}
```
Run 2 is a good example, maybe 10 as well
1 tries to split using depind and gender
run 4 is funniest on held0out but is most interpretable (same interpret as bbs) ==> it actually looks fine on held-out below.
held-out
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_test_index.csv')$x)
success.run <- c(1:10)

for (r in success.run) {
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_outpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```



#9 Sep

##To do
- Observe different runs of sgld
- Look at mcmc convergence
  - coda library and use mcmc diag on prediction. (maybe held-in, rather than out?)

##Results of SGLD in many runs
All runs have similar coverage performance

For run 1:8,10 since 9 only has 1 class
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(1:8)

for (r in success.run) {
  print(paste0("======== done ======", r))
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  for(C in c(1,2)){
  quants95 <- quantile(age.in[age.in$class==C,'pm_tf'], probs = c(0.025,0.975))
  print(quants95[2]-quants95[1])
  }
  
}
```
run 9 
```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(9)

for (r in success.run) {
  print(paste0("======== done ======", r))
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  for(C in c(1)){
  quants95 <- quantile(age.in[age.in$class==C,'pm_tf'], probs = c(0.025,0.975))
  print(quants95[2]-quants95[1])
  }
  
}
```

###Convergence

I will devise my own detection algorithm.
1. from mcmc_object. Observe sd(first 100) - sd(last 100) for each column.
2. Count number of cols which this value is positive



ChatGPT fix

```{r}
library(coda)

# Subset the subjects to a smaller number to reduce dimensionality
ind <- 1:500  # Try reducing the number of subjects to 500 for diagnostic purposes

# Function to read, process, and create MCMC objects
process_mcmc_object <- function(job_id, ind) {
  theta.matrix <- as.matrix(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_inpred__jobid_', job_id, '.feather')))
  splt <- split(theta.matrix[2,], theta.matrix[1,])  # Group 2nd row based on 1st row into a list
  rs <- sapply(splt, c)  # Create time x subject matrix
  rs <- rs[, ind]  # Select subjects based on index
  
  # Scale the data to reduce numerical instability
  # rs <- scale(rs)
  
  mcmc_object <- as.mcmc(rs)
  return(mcmc_object)
}

# Process the MCMC objects for different runs
mcmc_object1 <- process_mcmc_object(1, ind)
mcmc_object2 <- process_mcmc_object(3, ind)
mcmc_object3 <- process_mcmc_object(2, ind)
mcmc_object4 <- process_mcmc_object(5, ind)
# mcmc_object1 <- process_mcmc_object(1, ind)
# mcmc_object2 <- process_mcmc_object(2, ind)
# mcmc_object3 <- process_mcmc_object(3, ind)
# mcmc_object4 <- process_mcmc_object(5, ind)

#1,2,3,5,6,10

# Combine the MCMC chains into a list
mcmc.chain <- mcmc.list(mcmc_object1, mcmc_object2, mcmc_object3, mcmc_object4)

# Check if there are any columns (subjects) with zero variance
check_zero_variance <- function(mcmc_object) {
  apply(mcmc_object, 2, function(x) var(x) == 0)
}

# Identify subjects with zero variance across chains
zero_variance_subjects <- check_zero_variance(mcmc_object1) |
                          check_zero_variance(mcmc_object2) |
                          check_zero_variance(mcmc_object3) |
                          check_zero_variance(mcmc_object4)

if (any(zero_variance_subjects)) {
  warning("Some subjects have zero variance in all chains. These subjects will be removed.")
  # Filter out subjects with zero variance
  mcmc.chain <- lapply(mcmc.chain, function(chain) {
    chain[, !zero_variance_subjects]
  })
  mcmc.chain <- mcmc.list(mcmc.chain)  # Rebuild the mcmc.list
}

# Perform Gelman-Rubin diagnostic
r.hat <- tryCatch({
  gelman.diag(mcmc.chain)
}, error = function(e) {
  message("Gelman-Rubin diagnostic failed: ", e$message)
  NULL
})

if (!is.null(r.hat)) {
  # Print the Gelman-Rubin diagnostic
  # print(r.hat)
  print(sum(r.hat$psrf[,1]<1.1)/nrow(r.hat$psrf)*100)

} else {
  message("Could not calculate Gelman-Rubin diagnostic.")
}
```
100% converged, based on 500 training subjects
if not scaling, only 13.8% have converged on the "good" runs
but on bad, it's 4.8


It cannot run the test with >= 1000 subjects

```{r}
library(coda)

# Subset the subjects to a smaller number to reduce dimensionality
ind <- 1:57  # Try reducing the number of subjects to 500 for diagnostic purposes

# Function to read, process, and create MCMC objects
process_mcmc_object <- function(job_id, ind) {
  theta.matrix <- as.matrix(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_outpred__jobid_', job_id, '.feather')))
  splt <- split(theta.matrix[2,], theta.matrix[1,])  # Group 2nd row based on 1st row into a list
  rs <- sapply(splt, c)  # Create time x subject matrix
  rs <- rs[, ind]  # Select subjects based on index
  
  # Scale the data to reduce numerical instability
  rs <- scale(rs)
  
  mcmc_object <- as.mcmc(rs)
  return(mcmc_object)
}

# Process the MCMC objects for different runs
mcmc_object1 <- process_mcmc_object(1, ind)
mcmc_object2 <- process_mcmc_object(3, ind)
mcmc_object3 <- process_mcmc_object(6, ind)
mcmc_object4 <- process_mcmc_object(10, ind)

# Combine the MCMC chains into a list
mcmc.chain <- mcmc.list(mcmc_object1, mcmc_object2, mcmc_object3, mcmc_object4)

# Check if there are any columns (subjects) with zero variance
check_zero_variance <- function(mcmc_object) {
  apply(mcmc_object, 2, function(x) var(x) == 0)
}

# Identify subjects with zero variance across chains
zero_variance_subjects <- check_zero_variance(mcmc_object1) |
                          check_zero_variance(mcmc_object2) |
                          check_zero_variance(mcmc_object3) |
                          check_zero_variance(mcmc_object4)

if (any(zero_variance_subjects)) {
  warning("Some subjects have zero variance in all chains. These subjects will be removed.")
  # Filter out subjects with zero variance
  mcmc.chain <- lapply(mcmc.chain, function(chain) {
    chain[, !zero_variance_subjects]
  })
  mcmc.chain <- mcmc.list(mcmc.chain)  # Rebuild the mcmc.list
}

# Perform Gelman-Rubin diagnostic
r.hat <- tryCatch({
  gelman.diag(mcmc.chain)
}, error = function(e) {
  message("Gelman-Rubin diagnostic failed: ", e$message)
  NULL
})

if (!is.null(r.hat)) {
  # Print the Gelman-Rubin diagnostic
  # print(r.hat)
  print(sum(r.hat$psrf[,1]<1.1)/nrow(r.hat$psrf)*100)

} else {
  message("Could not calculate Gelman-Rubin diagnostic.")
}
```
For held-out it's also 100, tested on 57 subjects (note that heldout has 2k iterations instead of 500 like held-in)


Try matching 2,10 then 7,8 based on boxplots

```{r}
library(coda)

# Subset the subjects to a smaller number to reduce dimensionality
ind <- 1:400  # Try reducing the number of subjects to 500 for diagnostic purposes

# Function to read, process, and create MCMC objects
process_mcmc_object <- function(job_id, ind) {
  theta.matrix <- as.matrix(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_K2_inpred__jobid_', job_id, '.feather')))
  splt <- split(theta.matrix[2,], theta.matrix[1,])  # Group 2nd row based on 1st row into a list
  rs <- sapply(splt, c)  # Create time x subject matrix
  rs <- rs[, ind]  # Select subjects based on index
  
  # Scale the data to reduce numerical instability
  # rs <- scale(rs)
  
  mcmc_object <- as.mcmc(rs)
  return(mcmc_object)
}

# Process the MCMC objects for different runs
mcmc_object1 <- process_mcmc_object(3, ind)
mcmc_object2 <- process_mcmc_object(10, ind)

#1,2,3,5,6,10

# Combine the MCMC chains into a list
mcmc.chain <- mcmc.list(mcmc_object1, mcmc_object2)

# Check if there are any columns (subjects) with zero variance
check_zero_variance <- function(mcmc_object) {
  apply(mcmc_object, 2, function(x) var(x) == 0)
}

# Identify subjects with zero variance across chains
zero_variance_subjects <- check_zero_variance(mcmc_object1) |
                          check_zero_variance(mcmc_object2) |

if (any(zero_variance_subjects)) {
  warning("Some subjects have zero variance in all chains. These subjects will be removed.")
  # Filter out subjects with zero variance
  mcmc.chain <- lapply(mcmc.chain, function(chain) {
    chain[, !zero_variance_subjects]
  })
  mcmc.chain <- mcmc.list(mcmc.chain)  # Rebuild the mcmc.list
}

# Perform Gelman-Rubin diagnostic
r.hat <- tryCatch({
  gelman.diag(mcmc.chain)
}, error = function(e) {
  message("Gelman-Rubin diagnostic failed: ", e$message)
  NULL
})

if (!is.null(r.hat)) {
  # Print the Gelman-Rubin diagnostic
  # print(r.hat)
  print(sum(r.hat$psrf[,1]<1.1)/nrow(r.hat$psrf)*100)

} else {
  message("Could not calculate Gelman-Rubin diagnostic.")
}
```
pair (2,10) with 400 subjects corr 32.5%
pair (7,8) with 400 subjects corr 16.5%
let's try a random pair (3,10) => 24.75 wtf


#9 sep
SGLD:
I accidentally used 0.99/it.num as lr, should have used 1e-6
Now running
//aug22_pm_sm_gpols_12init_sgld_lr 10716591 => changed lr, and let it run for 750 epochs while recording only last 500

Held-in

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)
library(feather)

# Function to get the mode
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Load the age and sex stratified data
age_tab <- as.data.frame(read_feather('/well/nichols/users/qcv214/KGPNN/cog/agesex_strat2.feather'))

# Load the number of test cases
n.test <- length(read.csv('/well/nichols/users/qcv214/KGPNN/cog/cog_train_index.csv')$x)
success.run <- c(1:10)

for (r in success.run) {
  dat.in <- as.data.frame(t(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_lr_K2_inpred__jobid_', r, '.feather'))))[, c(1:3)]
  dat.in <- tail(dat.in, n.test / 4 * 1000)
  colnames(dat.in) <- c('id_ind', 'pred', 'class')
  dat.in.grouped <- dat.in %>%
    group_by(id_ind) %>%
    summarize(pred_class = getmode(class))
  dat.in.grouped <- dat.in.grouped[order(dat.in.grouped$id_ind), ]
  dat.in <- tail(dat.in, n.test)
  dat.in <- dat.in[order(dat.in$id_ind), ]
  dat.in$class <- dat.in.grouped$pred_class

  # Merge with age and sex information
  age.in <- age_tab[dat.in$id_ind, c('age', 'sex', 'DepInd', 'pm_tf')]
  age.in <- cbind(age.in, dat.in$pred, (dat.in$pred - age.in$pm_tf)^2, as.factor(dat.in$class))
  colnames(age.in) <- c('age', 'sex', 'DepInd', 'pm_tf', 'pred', 'SqError', 'class')
  
  # Calculate the median `pred` for each `class`
  class_order <- age.in %>%
    group_by(class) %>%
    summarise(median_pred = median(pred, na.rm = TRUE)) %>%
    arrange(median_pred) %>%
    pull(class)
  
  # Reorder the `class` factor based on the median `pred`
  age.in$class <- factor(age.in$class, levels = class_order)
  
  # Calculate class sizes
  class_sizes <- age.in %>%
    group_by(class) %>%
    summarise(count = n())
  
  # Create a named vector for custom labels
  class_labels <- paste0(class_sizes$class, " (n=", class_sizes$count, ")")
  names(class_labels) <- class_sizes$class
  
  # Reshape the data for plotting
  age.in_long <- pivot_longer(age.in, cols = c(age, sex, DepInd, pred, SqError, pm_tf), names_to = "variable", values_to = "value")
  
  # Create the boxplot with class sizes in the legend
  p <- ggplot(age.in_long, aes(x = class, y = value, fill = class)) +
    geom_boxplot() +
    facet_wrap(~ variable, scales = "free") +
    theme_minimal() +
    labs(title = paste("Boxplot of Age, Sex, and DepInd, tf_pm, Labeled by Class for Run", r),
         x = "Class",
         y = "Value") +
    scale_fill_discrete(labels = class_labels)
  
  print(p)
}
```

```{r}
library(coda)

# Subset the subjects to a smaller number to reduce dimensionality
ind <- 1:400  # Try reducing the number of subjects to 500 for diagnostic purposes

# Function to read, process, and create MCMC objects
process_mcmc_object <- function(job_id, ind) {
  theta.matrix <- as.matrix(read_feather(paste0('/well/nichols/users/qcv214/KGPNN/cog/pile/re_aug22_pm_sm_gpols_12init_sgld_lr_K2_inpred__jobid_', job_id, '.feather')))
  splt <- split(theta.matrix[2,], theta.matrix[1,])  # Group 2nd row based on 1st row into a list
  rs <- sapply(splt, c)  # Create time x subject matrix
  rs <- rs[, ind]  # Select subjects based on index
  
  # Scale the data to reduce numerical instability
  # rs <- scale(rs)
  
  mcmc_object <- as.mcmc(rs)
  return(mcmc_object)
}

# Process the MCMC objects for different runs
mcmc_object1 <- process_mcmc_object(2, ind)
mcmc_object2 <- process_mcmc_object(10, ind)

#1,2,3,5,6,10

# Combine the MCMC chains into a list
mcmc.chain <- mcmc.list(mcmc_object1, mcmc_object2)

# Check if there are any columns (subjects) with zero variance
check_zero_variance <- function(mcmc_object) {
  apply(mcmc_object, 2, function(x) var(x) == 0)
}

# Identify subjects with zero variance across chains
zero_variance_subjects <- check_zero_variance(mcmc_object1) |
                          check_zero_variance(mcmc_object2)

if (any(zero_variance_subjects)) {
  warning("Some subjects have zero variance in all chains. These subjects will be removed.")
  # Filter out subjects with zero variance
  mcmc.chain <- lapply(mcmc.chain, function(chain) {
    chain[, !zero_variance_subjects]
  })
  mcmc.chain <- mcmc.list(mcmc.chain)  # Rebuild the mcmc.list
}

# Perform Gelman-Rubin diagnostic
r.hat <- tryCatch({
  gelman.diag(mcmc.chain)
}, error = function(e) {
  message("Gelman-Rubin diagnostic failed: ", e$message)
  NULL
})

if (!is.null(r.hat)) {
  # Print the Gelman-Rubin diagnostic
  # print(r.hat)
  print(sum(r.hat$psrf[,1]<1.1)/nrow(r.hat$psrf)*100)

} else {
  message("Could not calculate Gelman-Rubin diagnostic.")
}
```



